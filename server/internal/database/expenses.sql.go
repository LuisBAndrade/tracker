// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: expenses.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (user_id, category_id, amount, description, date, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
RETURNING id, user_id, category_id, amount, description, date, created_at, updated_at
`

type CreateExpenseParams struct {
	UserID      uuid.UUID
	CategoryID  uuid.NullUUID
	Amount      string
	Description string
	Date        time.Time
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.UserID,
		arg.CategoryID,
		arg.Amount,
		arg.Description,
		arg.Date,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpense = `-- name: DeleteExpense :exec
DELETE FROM expenses WHERE id = $1 AND user_id = $2
`

type DeleteExpenseParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteExpense(ctx context.Context, arg DeleteExpenseParams) error {
	_, err := q.db.ExecContext(ctx, deleteExpense, arg.ID, arg.UserID)
	return err
}

const getExpenseByID = `-- name: GetExpenseByID :one
SELECT e.id, e.user_id, e.category_id, e.amount, e.description, e.date, e.created_at, e.updated_at,
       c.name as category_name, c.color as category_color
FROM expenses e
LEFT JOIN categories c ON e.category_id = c.id
WHERE e.id = $1 AND e.user_id = $2
`

type GetExpenseByIDParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type GetExpenseByIDRow struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	CategoryID    uuid.NullUUID
	Amount        string
	Description   string
	Date          time.Time
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CategoryName  sql.NullString
	CategoryColor sql.NullString
}

func (q *Queries) GetExpenseByID(ctx context.Context, arg GetExpenseByIDParams) (GetExpenseByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getExpenseByID, arg.ID, arg.UserID)
	var i GetExpenseByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.CategoryColor,
	)
	return i, err
}

const getExpenseTotalByUser = `-- name: GetExpenseTotalByUser :one
SELECT COALESCE(SUM(amount), 0) as total
FROM expenses
WHERE user_id = $1
`

func (q *Queries) GetExpenseTotalByUser(ctx context.Context, userID uuid.UUID) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getExpenseTotalByUser, userID)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const getExpenseTotalByUserAndDateRange = `-- name: GetExpenseTotalByUserAndDateRange :one
SELECT COALESCE(SUM(amount), 0) as total
FROM expenses
WHERE user_id = $1 AND date BETWEEN $2 AND $3
`

type GetExpenseTotalByUserAndDateRangeParams struct {
	UserID uuid.UUID
	Date   time.Time
	Date_2 time.Time
}

func (q *Queries) GetExpenseTotalByUserAndDateRange(ctx context.Context, arg GetExpenseTotalByUserAndDateRangeParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getExpenseTotalByUserAndDateRange, arg.UserID, arg.Date, arg.Date_2)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const getExpensesByCategory = `-- name: GetExpensesByCategory :many
SELECT 
    c.id as category_id,
    c.name as category_name,
    c.color as category_color,
    COALESCE(SUM(e.amount), 0) as total_amount,
    COUNT(e.id) as expense_count
FROM categories c
LEFT JOIN expenses e ON c.id = e.category_id AND e.user_id = $1 AND e.date BETWEEN $2 AND $3
WHERE c.user_id = $1
GROUP BY c.id, c.name, c.color
HAVING COUNT(e.id) > 0 OR $4 = true
ORDER BY total_amount DESC
`

type GetExpensesByCategoryParams struct {
	UserID  uuid.UUID
	Date    time.Time
	Date_2  time.Time
	Column4 interface{}
}

type GetExpensesByCategoryRow struct {
	CategoryID    uuid.UUID
	CategoryName  string
	CategoryColor string
	TotalAmount   interface{}
	ExpenseCount  int64
}

func (q *Queries) GetExpensesByCategory(ctx context.Context, arg GetExpensesByCategoryParams) ([]GetExpensesByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByCategory,
		arg.UserID,
		arg.Date,
		arg.Date_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesByCategoryRow
	for rows.Next() {
		var i GetExpensesByCategoryRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryName,
			&i.CategoryColor,
			&i.TotalAmount,
			&i.ExpenseCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesByUser = `-- name: GetExpensesByUser :many
SELECT e.id, e.user_id, e.category_id, e.amount, e.description, e.date, e.created_at, e.updated_at,
       c.name as category_name, c.color as category_color
FROM expenses e
LEFT JOIN categories c ON e.category_id = c.id
WHERE e.user_id = $1
ORDER BY e.date DESC, e.created_at DESC
LIMIT $2 OFFSET $3
`

type GetExpensesByUserParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetExpensesByUserRow struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	CategoryID    uuid.NullUUID
	Amount        string
	Description   string
	Date          time.Time
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CategoryName  sql.NullString
	CategoryColor sql.NullString
}

func (q *Queries) GetExpensesByUser(ctx context.Context, arg GetExpensesByUserParams) ([]GetExpensesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesByUserRow
	for rows.Next() {
		var i GetExpensesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.CategoryColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesByUserAndDateRange = `-- name: GetExpensesByUserAndDateRange :many
SELECT e.id, e.user_id, e.category_id, e.amount, e.description, e.date, e.created_at, e.updated_at,
       c.name as category_name, c.color as category_color
FROM expenses e
LEFT JOIN categories c ON e.category_id = c.id
WHERE e.user_id = $1 AND e.date BETWEEN $2 AND $3
ORDER BY e.date DESC, e.created_at DESC
`

type GetExpensesByUserAndDateRangeParams struct {
	UserID uuid.UUID
	Date   time.Time
	Date_2 time.Time
}

type GetExpensesByUserAndDateRangeRow struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	CategoryID    uuid.NullUUID
	Amount        string
	Description   string
	Date          time.Time
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CategoryName  sql.NullString
	CategoryColor sql.NullString
}

func (q *Queries) GetExpensesByUserAndDateRange(ctx context.Context, arg GetExpensesByUserAndDateRangeParams) ([]GetExpensesByUserAndDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByUserAndDateRange, arg.UserID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesByUserAndDateRangeRow
	for rows.Next() {
		var i GetExpensesByUserAndDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.CategoryColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpense = `-- name: UpdateExpense :one
UPDATE expenses
SET amount = $3, description = $4, category_id = $5, date = $6, updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, category_id, amount, description, date, created_at, updated_at
`

type UpdateExpenseParams struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	Amount      string
	Description string
	CategoryID  uuid.NullUUID
	Date        time.Time
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, updateExpense,
		arg.ID,
		arg.UserID,
		arg.Amount,
		arg.Description,
		arg.CategoryID,
		arg.Date,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
